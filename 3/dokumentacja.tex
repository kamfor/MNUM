% TeX encoding = utf8
% TeX spellcheck = pl_PL 
\documentclass[a4paper, 11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[polish]{babel}
\usepackage{polski}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{amsfonts}
\usepackage{geometry}
\usepackage{multicol}
\usepackage{latexsym}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{wrapfig}
\usepackage{color} %red, green, blue, yellow, cyan, magenta, black, white
\definecolor{mygreen}{RGB}{28,172,0} % color values Red, Green, Blue
\definecolor{mylilas}{RGB}{170,55,241}

\author{Kamil Foryszewski}
\title{Dokumentacja projektu laboratoryjnego numer 3 przedmiot MNUM}
\frenchspacing

\newgeometry{tmargin=2cm, bmargin=2cm, lmargin=2cm, rmargin=2cm}
\pagestyle{empty}


\begin{document}

\lstset{language=Matlab,%
    basicstyle=\color{red},
    breaklines=true,%
    morekeywords={matlab2tikz},
    keywordstyle=\color{blue},%
    morekeywords=[2]{1}, keywordstyle=[2]{\color{black}},
    identifierstyle=\color{black},%
    stringstyle=\color{mylilas},%
    commentstyle=\color{mygreen},%
    showstringspaces=false,
    numbers=right,%
    numberstyle={ \color{black}},% size of the numbers
    numbersep=5pt, % this defines how far the numbers are from the text
    emph=[1]{for,endfor,endwhile,endfunction,endif,break},emphstyle=[1]\color{blue}, %some words to emphasise
    emph=[2]{,.}, emphstyle=[2]\color{yellow},%
}

\maketitle
\tableofcontents

\section{Zadanie 1}

\subsection{Polecenie}
Proszę znaleźć wszystkie zera funkcji\\
\\
{$f(x) = 1.4*sin(x)-e^{x}=6*x-0.5$}\\
\\
w przedziale $[-5,5]$, używając dla każdego każdego zera programu z implementacją \\
a) metody bisekcji\\
b) metody siecznych\\
c) metody Newtona\\
 

\subsection{Metoda bisekcji}
\subsubsection{Opis teoretyczny}
Teoretyczny zarys metody bisekcji możemy przybliżyć poniższym algorytmem:
\begin{enumerate}
  \item Począwszy od przedziału startowego $[a,b]$ = $[a_{0},b_{0}]$ obliczamy środek przedziału $c_{n}$\\
  $c_{n} = \frac{a_{n}+b_{n}}{2}$\\
  i obliczamy wartość $f(x)$ w tym punkcie. 
  \item Obliczamy iloczyny $f(a_{n})*f(c_{n})$ oraz $f(b_{n})*f(c_{n})$ I jako nowy przedział $[a_{n=1},b_{n+1}$
  wybieramy ardumenty tego iliczynu którego wartość jest ujemna. 
\end{enumerate} 
Kroki te powtarzamy aż do mementu uzyckania $f(c_{n})<\delta$ gdzie $\delta$ to oczekiwana dokładność rozwiązania. W przypadku "płaskich" funkcji warto też konrtolować długość rozpatrywanego przedziału. 
Dokładność wyniku zalezy jedynie od ilośći iteracji dlatego metoda jest zbierzna liniowo z ilorazem zbierzności 0,5. Co czyni ją stosunkowo wolno zbierzną w przypadku wyboru szerokiego przedziału początkowego. 



\subsubsection{Realizacja w programie Matlab}
\begin{lstlisting}
%funkcja wyznaczajaca zera funkcji metoda bisekcji
function bzeropoint = bisection(fun,l,r,iter)
%Dane wejsciowe:	l,r - lewa i prawa sterona przedzialu poszukiwan
%			fun - funkcja 
%			iter - maksymalna liczba uteracji
%Dane wyjsciowe: zerospoint - wyznaczone miejsce zerowe
  a = l; 
  b = r;
  fa =feval(fun,a);     %  Wartosci poczatkowe f(a) i f(b)
  fb =feval(fun,b);
  for k=1:iter
    xm = a + 0.5*(b-a);    %  Poprawne obliczenie srodka przedzialu
    fm = feval(fun,xm);      %  f(x) w srodku przedzialu
    fprintf('%3d %12.16f %12.16f %12.16f %12.3e\n',k,a,xm,b,fm);
    if(fm == 0)
        return
    end
    if sign(fm)==sign(fa)    %  Zero lezy w przedziale [xm,b], zamiana a
        a = xm;
        fa = fm;
    else                     %  Zero lezy w przedziale [a,xm], zamiana b
        b = xm;
        fb = fm;
    end
  end
  bzeropoint = xm; 
  return
end
\end{lstlisting}

\subsection{Metoda siecznych}
\subsubsection{Opis teoretyczny}
Teoretyczny zarys metody siecznych możemy przybliżyć poniższym algorytmem:
\begin{enumerate}
  \item Począwszy od przedziału startowego $[a,b]$ = $[a_{0},b_{0}]$ obliczamy punkt $x_{n}$ jako miejcse przecięcia siecznej funkcji przechodzącej prze punkty $[a_{n},b_{n}]$ gdzie $x_{n}=$
  \item Nastpepnie nowy przedział oznaczamy $x_{n+1}=$ 
\end{enumerate} 
Kroki te powtarzamy aż do mementu uzyckania $f(c_{n})<\delta$ gdzie $\delta$ to oczekiwana dokładność rozwiązania. Rząd zbierzności metody siecznych wynosi $(1+sqrt(5))/2$ co jest w przybliżeniu równe $1.618$. 
Jwst więc ona dużo szybsza od metody bisekcji, jednak jest zbierzna jedynie lokalnie. Jeżeli ine zadbamy o wybór odpowiedniego przedziału początkowego może okazać się wogóle nie zbieżna. 


\subsubsection{Realizacja w programie Matlab}
\begin{lstlisting}
%funkcja obliczajaca zera funkcji metoda siecznych
function szeropoint = secant(fun,l,r,iter)
%Dane wejsciowe:	l.r - lewa i prawa sterona przedzialu poszukiwan
%			fun - funkcja 
%			iter - maksymalna liczba uteracji
%Dane wyjsciowe: zerospoint - wwyznaczone miejsce zerowe
  a = l;
  b = r;
  fa = feval(fun,a); %wartosc funkcji w punkcie start.
  for k = 1:iter
    fb = feval(fun,b);
    dx = fb * (b-a) / (fb-fa); %wyznaczenie przeciecia sieczna
    xm = b-dx; %zawezenie przedzialu
    if(isnan(xm))
        return
    end
    a = b;
    b = xm;
    fa = fb;
    szeropoint = b;
    fprintf('%3d %12.16f %12.16f %12.16f %12.3e\n',k,a,xm,b,dx);
    if(fb == 0) %dodatkowy warunek zakonczenia wykonywania
        return
    end
  end
end
\end{lstlisting}

\subsection{Metoda Newtona}
\subsubsection{Opis teoretyczny}
Metoda Newtona polega na wyznaczeniu cześciowego (uciętego) rozwinięcia w szereg Taylora danej funkcji, które możemy trakować jak liniowe przybliżenie funkcji według wzoru:\\
\\
$f(x) \approx f(x_{n})+f'(x_{n})(x-x_{n})$\\
\\
Nastepnie wyznaczamy koljene punkty iteracji poprzez przywórnanie do zera otrzymanej aroksymacji:\\
\\
$f(x_{n})+f'(x_{n})(x_{n+1}-x_{n}) = 0$\\
\\
Prowadzi to do zależności iteracyjnej danej następującym wzorem:\\
\\
$x_{n+1} = x_{n}-\frac{f(x_{n})}{f'(x_{n})}$\\
\\
Metoda Newtona jest zbierzna jedynie lokalnie ponieważ wyznaczjąc styczną do wykresu w danym punkcie możemy w przypadku ujemnego znaku pochodnej dojsć do rozbierzności. Dla przypadków pochodnej większej od zera metoda jest zbierzna kwadratowo. Rząd zbierzności wynosi 2. Dlatego nadaje się dla stromych funkcji. 

\subsubsection{Realizacja w programie Matlab}
\begin{lstlisting}
%funkcja obliczajaca zera funkcji metoda Newtona
function nzeropoint = newton(fun,l,iter)
%Dane wejsciowe:	l prawa sterona przedzialu poszukiwan
%			fun - funkcja 
%			iter - maksymalna liczba uteracji
%Dane wyjsciowe: zerospoint - wyznaczone miejsce zerowe
    
  x0 = l; 
  for k = 1:iter
    [fold, fpold] = feval(fun,x0); 
    dx = fold / fpold; %wyznaczenie przyrostu funkcji
    x0 = x0 - dx;
    fprintf('%3d %12.16f %12.16f %12.3e\n',k,x0,dx,fold);
    if(fold == 0)
        return
    end
	if fold==0 %dodatkowy warunek zatrzumania
        nzeropoint = x0;
        break; 
     end
  end
end
\end{lstlisting}

\subsection{Analiza danych wejściowych}
W celu wyznaczenia przedziałów izolacji miejsc zerowych został wykorsyztany algorytm opisany w skrypcie prof. Tatjewskiego. Wstępna analiza danych rozpoczyna się od wygenerowania wykresu funkcji w danym przedziale i na tej podstawie wyboru przedziału startowego dla algorytmu. Nastepnie w podanycm przedziale w pętli badany jest znak iloczynu funkcji w punktach graniczynych. Jezeli jest on ujemny, oznacza to występowanie miejsca zerowego w danycm przedziale. Jeżeli nie to przedział jest rozszerzany do momentu przekroczenia przedziału danego w zadaniu. 
Poniżej wykres funkcji z zaznaczonymi przedziałami izolacji wyznaczonymi przez algorytm. 


\subsection{Skrypt generujący rozwiązanie zadania w programie Matlab}
\begin{lstlisting}
%Realizacja zadania 1
clear; 
%Generowanie wykresu funkcji aby sprawdzic poprwanosc otrzymanych rozwiazan 
x  = -5: .1 : 5;
plot(x, fun(x), 'b','LineWidth', 2)
grid on
axis([-5 5 -150 150])

n=100; 
x1 = -1; 
x2 = 0; 

%wyznaczanie przedzialow izolacji na podstawie wkryptu MNUM
for k=1:2
    for j=1:n
        if fun(x1)*fun(x2)<0
            a = x1;
            b = x2;
            fprintf('Wyniki dla %d miejsca zerowego w przedziale [%d,%d]\n',k,a,b);
            bisection('fun',a,b,100);
            secant('fun',a,b,100);
            newton('fun',a,100);
            x1 = 3; 
            x2 = 4; 
            break;
        elseif abs(fun(x1))<abs(fun(x2))
            x1 = x1+1.1*(x1-x2);
        else
            x2 = x2+1.1*(x2-x1);
        end
        if(x1>5)&&(x2<(-5))
            break; %wyjscie z petli po przekroczeniu przedzialu
        end
    end
end
\end{lstlisting}
\vspace{1cm}


\subsection{Wyniki}
%wykres 
%tbelka


\subsection{Wnioski}
Analizując wykres funkcji danej w zadanu możemy wstępnie okreslić miejsca zerowe i zachowanie funkcji w ich otoczeniu. Rozpatrywana funkcja posiada dwa rodzaje miejsc zerowych które mają wpływ na szybkość ich wyznaczania, ponieważ w otoczeniu jednego z nich funkcja jest nachylona pod małym kątem do osi X natomiast w przypadku drugiego miejsca obserwujemy duży kolakny przyrost, więc wykres funkcji jest niewiele odchylony od osi pionowej. Jak wynika z otrzymanych rezultatów metoda bisekcji w obu przypadkach potrzebowała stosunkowo dużej ilości iteracji aby osiągnać zadaną dokładność. Jej zaletami jest niewrażliwość na szczególne zachowania funkcji więc mimo słabej zbierzności nadaje się do wyznaczania miejsc zerowych funkcji których przebiegu nie znamy w celu zabezpieczenia przez niezbierznością. Metoda siecznych potrzebowała około 10 iteracji aby dojść do wyniku. W przypadku wyznaczania miejsca zerowego w otoczeniu którego mamy doczynienia z płaską funkcją, jak miało to miejsze w zadaniu w drugim miejscu zerowym, metoda okazuje się najlepsza spośród wszystkich zastosowanych. Jej wadą jest niezbieżność w przypadku gdy sieczna przetnie wykres funkcji w większej ilości miejsc niż 2. Dlatego najeży wybierać wąskie przedziały startowe co zostsało uczynine w rozwiązaniu. Ostatnią wypróbowaną metodą jest metoda Newtona (stycznych), która w przypadku dobrego uwarunkowania (wąski przedział, brak odcinków o pochodniej mniejszej niż zero w przedziale startowym) okazuje się być najszybsza ( w zadaniu ok 3-4 iteracje). Wynika to z najwyższego współczynnika zbierzności. 


\section{Zadanie 2}

\subsection{Polecenie}
Używając metody Mullera MM2, proszę znaleźć wszystkie pierwiastki rzeczywiste i zespolone wielomianu \\
$f(x) = a_{4}x^4+a_{3}x^3+a_{2}x^2+a_{1}x+a_{0}$ 
$
\left[
\begin{array}{ccccc}
       a_{4} & a_{3} & a_{2} & a_{1} & a_{0}
\end{array}
\right]
=
\left[
\begin{array}{ccccc}
       1 & 2 & 4 & -1 & 8
\end{array}
\right]$


\subsection{Metoda Mullera MM2}
Metoda Mulllera polega na przybliżeniu rozpatrywanej funkcji trójmianem kwadratowym w otoczeniu zera i na tej podstawie wyznaczeniia miejsca zerowego . 


\subsection{Realizacja w programie Matlab}
\begin{lstlisting}

\end{lstlisting}

\vspace{2cm}

\subsection{Wyniki działania programu}
%analitycnznie
%tabelka z programu

\vspace{10cm}
\subsection{Wnioski}

	
\end{document}


